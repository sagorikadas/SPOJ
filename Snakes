/*
Snakes and Ladders
Algo: BFS
*/

#include <iostream>
#include <list>
#include <algorithm>
#include <queue>
using namespace std;

list<int> *adj;

void addEdge(int u,int v)
{
	adj[u].push_back(v);
}


int BFS()
{
	 bool *vis= new bool[101];
	 int *level=new int[101];
     for (int i = 0; i < 101; ++i)
     {
     	level[i]=-1;
     	vis[i]=false;
     }
     queue <int> q;
     level[1]=0;
     q.push(1);

     while(!q.empty())
     {
     	int u=q.front();
     	q.pop();
     	list<int>::iterator it;

     	for(it=adj[u].begin();it!=adj[u].end();it++)
     	{
             if(!vis[*it]){
                           vis[*it]=true;
             	level[*it]=level[u]+1;
                 q.push(*it);
             }
     	}
     }
  return level[100];
}

 int main()
{
	
int T;
     cin>>T;
     while(T--)
     
  {
         adj=new list<int>[101];
   for(int i=1;i<101;i++)
   {
   for(int j=1;j<7;j++)
   {
    if(i+j<101)
    addEdge(i,i+j);    	
   }
 }
 
 
int lad;
cin>>lad;

for (int i = 0; i < lad; ++i)
{
	int l,r;
	cin>>l>>r;

	list<int>::iterator it;
	for(int j=1;j<101;j++)
	{
		for (it = adj[j].begin(); it!= adj[j].end(); ++it)
		{
			if(*it==l)
                *it=r;
              
		}
	}
    
    adj[l].clear();	
}

int sna;
cin>>sna;

for (int i = 0; i < sna; ++i)
{
	int l,r;
	cin>>l>>r;

	list<int>::iterator it;
	for(int j=1;j<101;j++)
	{
		for (it = adj[j].begin(); it!= adj[j].end(); ++it)
		{
			if(*it==l)
                *it=r;
		}
	}
    
    adj[l].clear();	
}

cout<<BFS()<<endl;

     }

    return 0;
}
